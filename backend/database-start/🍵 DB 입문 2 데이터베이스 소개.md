### 6강. 데이터와 정보

정보 - Data vs. Information
쇼핑몰을 운영한다고 가정하자

1단계
Data - 문맥(Context) 없는 날것(Raw)의 데이터, 조각난 텍스트 모음
1.5단계
Structured Data - 구조화된 데이터, 엑셀 스프레드시트(표) 형식
2단계
Information - Data에서 특정한 목적이나 질문을 갖고 분석, 가공해서 얻은 결과물

**특정 날짜에 가장 많이 팔린 제품**
- **필터링 (Filtering) - 주문일자 선택**
- **그룹화 및 집계 (Grouping & Aggregation) - 상품명으로 그룹화, 그 수량을 집계(합산)**

목적을 갖고 얻은 정보 Information
"최다 판매 상품" "총 매출액" "재구매 고객" 등

의사 결정(경영): 정보 -> 의사결정
- 많이 팔리는 상품 -> 재고 관리
- 누가 충성 고객인가 -> 맞춤형 마케팅
- 날짜별 매출 추이 -> 프로모션 진행

데이터베이스(Database) = data + base, 정보 저장소

### 7강. 데이터베이스 관리 시스템이 필요한 이유

만약 "고객 - 상품 - 주문내역"을 관리한다고 하자
텍스트 파일로 관리하는 건 불편하겠지
그럼 엑셀 파일로 관리하는 건?

<h4>파일에 직접 데이터를 저장, 관리할 때의 문제점</h4>
1. **데이터 중복(Redundancy), 데이터 불일치(Inconsistency)**
   중복으로 관리되는 내역이 있다면 (예: 고객의 이름과 전화번호, 주소)
   한 곳에서 업데이트했을 때 다른 곳에서는 반영이 안 될 것이다 (예: 고객 정보에선 반영이 됐는데 주문내역에서는 반영이 안 되어있음, 일일이 수정해줘야 함)
2. **데이터 접근의 어려움**
   '서울 강남' 거주하는 고객들의 '운동화' '총 구매액'을 구한다면 어떻게 할 것인가?
   원하는 조건으로 데이터를 검색하거나, 여러 파일에 흩어져 있는 데이터를 조합해 의미 있는 정보를 얻어내기가 어렵다.
3. **데이터 무결성 제약조건 적용의 어려움**
   예를 들어, 주문 수량은 1개 이상, 상품 가격은 0 이상과 같은 데이터 무결성 제약조건을 강제하기가 어렵다. 주문 수량에 0, 상품 가격에 음수를 입력해도 파일은 그냥 받아들인다.
   모든 유효성 검사를 데이터 입력 애플리케이션(예: 주문 관리 프로그램)에서 처리해야 한다.
   즉, 데이터 무결성 제약조건 적용을 위한 체계적 지원이 부족하다
4. **동시성 제어(Concurrency Control)의 문제**
   여러 사용자가 동시에 같은 데이터에 접근해서 수정하려고 할 때,
   즉 재고가 1개 남았는데 동시에 두 고객이 구매하겠다고 했을 때, 두 운영자가 주문을 접수하고, 재고를 1에서 0으로 작성하면 두 고객에게 주문 가능하다고 대답할 수 있다.
5. **보안 문제**
   만약 고객 정보에 이름, 주소, 전화번호와 민감정보인 주민등록번호, 계좌번호가 있다고 하자
   누구에겐 이름과 주소, 전화번호까지만 보여주고, 재무팀 직원에겐 계좌번호까지 보여주고
   이런 식으로 권한 설정을 다르게 할 수 있을까? 
   일반적인 파일 시스템의 접근 권한 설정(읽기, 쓰기, 실행 권한 등)만으로는 이렇게 세밀한 데이터 접근 제어가 어렵다. 이는 데이터 유출의 위험을 높인다.
   그러나 실무에서는 중요한 비즈니스 데이터, 특히 개인 정보는 철저한 보안 관리가 필수적이다.
6. 데이터 복구 및 백업의 어려움
   만약 실수로 파일을 삭제하거나 하드디스크가 고장난다면? 파일 백업을 해두지 않았다면 모든 정보를 날리는 상황이 발생할 수도 있다.
   백업이 있다고 해도, 직전의 최신 상태 데이터인지는 보장할 수 없다.
   데이터는 비즈니스의 핵심 자산이므로, 어떤 장애 상황에서도 안전하게 보호되고 신속하게 복구될 수 있는 체계가 필요하다.
   
지금까지 파일 시스템으로 데이터를 관리할 때 발생할 수 있는 다양한 문제점들을 살펴보았다. 데이터 중복 및 불일치, 데이터 접근의 어려움, 무결성 유지의 어려움, 동시성 제어 문제, 보안 문제, 그리고 회복과 백업의 어려움까지.
이 강의에서 우리가 쇼핑몰을 운영한다고 가정했을 때, 쇼핑몰이 성장함에 따라 이런 문제들은 점점 더 심각해지고, 결국에는 쇼핑몰 운영 자체가 불가능해질 수도 있다.

데이터베이스 관리 시스템은 단순히 파일에 데이터를 모아둔 것을 넘어, 데이터를 보다 체계적으로 구성하고, 앞서 언급 된 문제점들을 해결하기 위한 다양한 기능들을 제공한다.

- 데이터 중복을 최소화하고 일관성을 유지하며,  
- 다양하고 복잡한 조건으로도 쉽게 데이터를 검색하고 활용할 수 있게 하며, 
- 데이터의 무결성 규칙을 강제하여 데이터의 품질을 높이며,  
- 여러 사용자가 동시에 접근해도 데이터가 안전하게 처리되도록 제어하며, 
- 정교한 보안 정책을 통해 데이터 접근을 통제하며,  
- 장애 발생 시 데이터를 안전하게 복구하고 백업할 수 있는 기능을 제공한다.

즉, 데이터베이스 관리 시스템은 우리 쇼핑몰의 소중한 데이터를 안전하고 효율적으로 관리하여, 우리가 필요로 하는 정보를 언제든지 정확하게 얻을 수 있도록 도와주는 핵심 기반 시설이라고 할 수 있다.

결국 어떤 시스템을 만들든 DBMS는 필수가 된다 

---

### 8강. 데이터베이스 관리 시스템 (DBMS) 소개

지난 시간에는 파일 시스템으로 데이터를 관리할 때 발생하는 다양한 문제점들에 대해 알아보았다. 데이터가 중복되고, 일관성이 깨지고, 찾기도 어렵고, 보안도 허술하고, 여러 사람이 동시에 쓰기도 힘들고, 고장 나면 복구도 어렵고... 우리 쇼핑몰이 이런 식으로 운영된다면 정말 큰일일 것이다.

**데이터베이스 관리 시스템(DBMS, Database Management System)**

데이터베이스에 엑셀이나 다른 파일도 포함됨 (고객 정보, 상품 정보, 도서 목록 등)

데이터 베이스 관리 시스템
DBMS란, 사용자와 DB 사이에서 DB의 관리와 사용을 도와주는 프로그램이다.

![DBMS 그림](./attachments/🍵%20DB%20입문%201%20강의%20소개.png)

- DBMS는 DB를 관리할 수 있는 프로그램이다. (생성, 조회, 수정, 삭제, 검색 등)
- 데이터는 사람이 읽을 수 있는 텍스트, CSV 파일이 아닌 이진 형식 파일에 저장됨
- 개발자나 사용자는 DBMS의 내부적인 작동 원리를 알 필요가 없다 (추상화)
- 대신 SQL과 같은 표준화된 언어를 사용하여 DBMS에 요청을 한다.
- DBMS가 사용하는 파일들을 직접 열어보거나 수정하려고 해선 안 된다. 파일 손상의 우려가 있다. (데이터 손상 또는 DBMS 시스템 전체에 문제가 생길 수 있음)

결론적으로, DBMS는 개발자가 파일 시스템의 복잡한 부분을 직접 다루지 않도록 하고, 대신 **데이터를 보다 체계적이고 안전하며 효율적으로 관리할 수 있는 추상화된 방법을 제공한다.**

==DBMS의 역할(요약)==
- 데이터 정의: 주제별 분류
- 데이터 생성: 데이터 등록
- 데이터 관리: 카탈로그
- 데이터 제어, 보안: 민감정보 관리
- 데이터 무결성: 데이터 훼손 방지
- 백업 및 복구: 안전한 보관
- 동시성 제어: 한 번에 여러 사용자의 요청

---
#### 참고 자료 - 파일 저장 방식
<h5>DBMS 파일 형식</h5>
개요
- 흔히 사용하고, 사람이 읽을 수 있는 `.txt` `.csv` 형식이 아닌 이진 형식(Binary)
- 운영체제 파일 시스템 위에서 페이지 또는 블록 단위로 구조화된 객체들의 집합
- 운영체제 입장에서는 이진 형식(바이너리) 파일 하나 또는 여러 개일 뿐
- 하지만 내부의 자료구조(B-Tree, Linked List etc)가 바이트(Byte) 단위로 직렬화되어 있어, 쿼리 엔진이 필요한 부분만 찾아내기 쉽게 되어 있음. 

상세
- 고정된 크기의 페이지/블록(4KB, 8KB, 16KB etc)이 배열처럼 나열되어 있음
- I/O 효율성: 디스크에서 데이터를 읽을 때, 레코드가 포함된 페이지 전체를 메모리로 올림(Buffer Pool) - 속도 향상
- 파일 내부의 자료 구조는 힙 파일(Heap File), 인덱스(B-Tree, B+ Tree) 구조가 대표적임. 인덱스 구조는 파일 자체가 정렬된 트리로 저장되거나(Clustered Index), 별도의 인덱스 파일이 트리 형태로 데이터 파일의 위치(포인터)를 가리킴

텍스트나 CSV 파일이 아닌 이진 형식 파일을 쓰는 이유
- **빠른 속도**: 텍스트 파일은 구문 분석(Parsing)을 해야 해서 느림(콤마 위치를 찾아야 함). 하지만 이진 형식 파일은 데이터 타입을 강제하여(예: `INT`(4Byte)) 레코드(행)의 위치를 **바이트 오프셋 연산**으로 빠르게 찾을 수 있음.
- **메타데이터 저장**: 파일 헤더에 비어있는 공간(Free Space), 페이지 체크섬(Checksum), 트랜잭션 ID 등을 함께 기록하여 **무결성을 보장**
- **동시성 제어**: 텍스트 파일은 한 줄을 수정하면 전체 페이지가 수정되어야 하지만, DBMS의 이진 형식 파일은 특정 페이지만 잠그거나(Lock) 수정할 수 있음.

오프셋(Offset)이란?
- 기준점이나 위치에서 특정한 거리만큼 떨어진 편차나 간격, 차이를 말함
- 컴퓨터 과학에서도 기준값 대비 데이터 변위를 말함
- 데이터 베이스 쿼리에서 결과 집합의 시작 지점을 특정 수만큼 건너뛰어 가져오는 기준점을 말함. (예를 들어, OFFSET 10은 상위 10개 데이터를 건너뜀.)

실제 파일 확장자와 예시
- 각 제공사(Vendor)마다 고유의 이진 형식(Binary format)을 사용함.

| DBMS       | format                   | description                                                  |
| ---------- | ------------------------ | ------------------------------------------------------------ |
| MySQL      | `.ibd`                   | 테이블스페이스 파일. 테이블의 데이터와 인덱스가 페이지 단위로 직렬화되어 저장됨 (Serialization) |
| Oracle     | `.dbf`                   | 데이터 파일                                                       |
| SQL Server | `.mdf`(Main) `.ldf`(Log) | 주 데이터 파일, 로그 파일                                              |
| PostgreSQL | 없음                       | 특정 디렉토리(`base/`) 아래에 숫자로 된 파일명(OID)으로 저장됨. 페이지 단위.           |
추가
- DBMS는 데이터를 빨리 찾기 위해 인덱스(Index)를 사용
- 데이터 유실을 막기 위한 로그 파일(WAL)이 존재

<h5>MongoDB(NoSQL) 파일 저장 형식</h5>

특징
- MongoDB과 같은 NoSQL, 문서 지향(Document-oriented) DB도 이진 형식의 파일에 데이터를 저장함.
- MongoDB Shell에서는 JSON 형식으로 보이지만, 실제로 저장할 때는 BSON(Binary JSON) 형식으로 저장됨
- 마찬가지로 직렬화된 데이터, 파싱 필요없음, 바이트 오프셋 계산 가능
- 저장 엔진(스토리지 엔진)은 WiredTiger, 확장자 `.wt` 
- 컬렉션 파일이나 RDBMS처럼 인덱스(B-Tree) 파일로 저장
- 블록 압축으로 JSON 데이터가 텍스트일 때보다 용량이 적음

RDBMS와 비교

| **특징**     | **RDBMS (MySQL 등)**     | **MongoDB (WiredTiger)**    |
| ---------- | ----------------------- | --------------------------- |
| **기본 포맷**  | 고정된 행(Row)              | **가변 길이** 문서 (BSON)         |
| **파일 구조**  | 테이블스페이스 (`.ibd`)        | 컬렉션 파일 (`.wt`)              |
| **데이터 접근** | 오프셋 계산 (고정 길이이므로 쉬움)    | **길이 기반 탐색** (헤더의 길이 정보 활용) |
| **특이점**    | 빈 칸(Null)도 공간을 차지할 수 있음 | 데이터가 없으면 아예 저장 안 함 (Sparse) |

---
#### DBMS의 역할과 기능

2026-01-23

요약
1. 데이터 정의 (DDL) - 테이블, 컬럼, 데이터간의 관계, 데이터 타입, 제약조건
2. 데이터 조작 (DML) - 등록/조회/수정/삭제(Insert, Select, Update, Delete)
   특히, RDBMS에서는 SQL이라는 표준화된 언어를 주로 사용함
3. 보안, 동시성 제어, 트랜잭션 관리
4. 데이터 중복 최소화, 일관성 유지
5. 데이터 백업, 복구

상세
데이터 정의 (DDL)
- 쇼핑몰의 경우 `고객(Customers)` 테이블, `상품(Products)` 테이블, `주문(Orders)` 테이블 등을 만든다.
- 각 테이블에 어떤 항목(예: 고객 테이블에는 고객ID, 이름, 이메일, 주소 등)이 들어갈지 정의한다.
- 각 항목의 데이터 타입(예: 고객ID는 정수형, 이름은 문자열)은 무엇인지 정의한다.
- '고객ID는 반드시 존재해야 한다(`NOT NULL` )', '이메일은 유일해야 한다 (`UNIQUE`)같은 제약조건도 설정할 수 있다.

데이터 조작 (DML)
- 새로운 고객이 가입하면 `고객` 테이블에 정보를 등록한다. 
- "지난달 가장 많이 팔린 상품 Top5"를 알고 싶을 때, `주문` 테이블과 `상품` 테이블에서 조건에 맞는 데이터를 조회한다.
- 고객이 주소가 바뀌면 `고객` 테이블의 주소 정보를 수정한다.
- 단종된 상품 정보를 `상품` 테이블에서 삭제한다.

(추가 메모)
> **<트랜잭션>**
> ==트랜잭션 = 묶음 작업 처리==
> ==원자 = 깨지지 않는 하나의 단위를 상징==
> 원자성 = 트랜잭션을 통해 데이터의 일관성 보장
> 출금&입금은 성공&성공이거나 실패&실패여야 함 (데이터의 상태가)
> 트랜잭션 관리란 성공&실패면 실패&실패로 돌리는 것
> DBMS에서 되게 중요한 내용 중 하나!

보안, 동시성 제어, 트랜잭션 관리
- 보안(Security) - 허가된 사용자만 접근 가능하도록 관리, 사용자별로 접근 가능 데이터 범위, 수행 가능한 작업(읽기, 쓰기, 수정 등) 제한)
- 동시성 제어(Concurrency Control) - 순서 제어, 잠금(Locking) 메커니즘
- 트랜잭션 관리(Transaction Management) - 원자성(Atomicity), 커밋/롤백
  예: 계좌 이체는 (1) 나의 돈 출금 (2) 대상 계좌에 입금. 둘 다 성공/되돌리기
  DBMS는 트랜잭션 관리를 통해 데이터의 일관성과 안정성을 보장함

> **정규화**
> 고객 데이터 / 주문 데이터 분리 등
> 분리한 테이블 한꺼번에 볼 수 있는 방법 있음 (JOIN)
> 
> **로그 파일**
> 변경이 발생할 때마다 변경사항 추적
> 특정 시점으로 복원도 가능

데이터 중복 최소화, 일관성 유지
- <u>정규화(Normalization) - 불필요한 데이터 중복을 줄임.</u>
  데이터를 수정할 때 여러 곳을 고칠 필요가 없고, 저장 공간도 확보 가능
- 예시: 고객의 주소 정보는 `고객` 테이블에 한 번만 저장하고, `주문` 테이블에서는 해당 고객의 ID만 참조하도록 하면, 고객이 이사했을 때 `고객` 테이블의 주소만 수정하면 모든 주문에서 변경된 주소를 참조할 수 있다.

데이터 백업 및 복구 (Data Backup and Recovery)
- DBMS는 시스템 장애(예: 하드디스크 고장, 정전)나 사용자 실수로 인해 데이터가 손상되거나 유실될 경우를 대비하여, 데이터를 주기적으로 백업하고 문제 발생시 안전하게 복구할 수 있는 기능을 제공한다. 로그(Log) 파일을 기록하여 변경 사항을 추적하고, 이를 통해 특정 시점으로 데이터를 복원할 수도 있다.

정리하자면, 
DBMS는 **데이터를 정의하고, 조작하고, 관리함으로써 데이터의 품질, 보안, 안정성을 보장**하는 중요한 소프트웨어**다.

### 9강. 관계형 데이터베이스 vs NoSQL

예전
- 파일 시스템 - 아날로그, 엑셀 등
- 계층형, 네트워크형 DBMS - 사장됨
- ==관계형 DBMS (RDBMS)== - <메인> 가장 널리 쓰임
- ==NoSQL(Not Only SQL) DBMS== - <옵션> 빅데이터 처리, 특수 요구사항

"데이터를 어떻게 하면 더 효과적이고 안전하게 관리할 수 있을까?"

<h4>관계형 데이터베이스 관리 시스템 (RDBMS - Relational Database Management System)</h4>

줄여서 RDB라고 부름
통상적으로 DB라고 부름
실무에서 관계형 데이터베이스, 데이터베이스

**테이블간에 관계를 가지고 있다** -> SQL

테이블 - 표
행 - Row, 레코드
열 - Column, 필드, 속성

대표적 RDBMS 종류
- MySQL - 데이터베이스 입문 강의
- MariaDB - MySQL에서 파생
- Oracle - 금융쪽에서 쓴다고 했던 것 같음
- Microsoft SQL Server
- PostgreSQL

RDBMS가 상용화된 이유
- 데이터 구조가 명확함, 무결성 보장
- ACID 트랜잭션 보장 - ACID(원자성, 일관성, 고립성, 지속성)
- SQL이라는 표준 질의어 - 쉽고 강력하게 데이터 조회나 조작을 할 수 있다
- 풍부한 커뮤니티, 관련문서, 도구 - 수십년간 축적된 성숙한 기술
- 실무에서의 압도적 사용 빈도 - 백엔드 개발자라면, 실무에서 기본적으로 RDBMS를 사용, 다른 DB는 특정 필요에 따라 옵션으로 사용됨

RDBMS 없이 프로젝트를 진행하는 경우는 (아주 특별한 경우 아니면) 거의 없다
NoSQL과 같은 다른 DB는 RDBMS를 제대로 마스터하고 나서 필요할 때 배우면 된다

<h4>NoSQL 데이터베이스 관리 시스템 (Not Only SQL)</h4>

관계형 모델을 사용하지 않거나, SQL을 주요 데이터 접근 언어로 사용하지 않는 DBMS
특정한 상황에 사용한다 (엄청나게 많은 비정형 데이터 등)

NoSQL 간단 정리 - 4개로 분류

| 분류         | 데이터 단위       | 핵심 장점        | 대표 사례    | 대표 DBMS            |
| ---------- | ------------ | ------------ | -------- | ------------------ |
| 키-값 저장소    | 키-값 한 쌍      | 초고속 단건 읽기/쓰기 | 세션, 캐시   | Redis, Memcached   |
| 문서 DB      | JSON/BSON 문서 | 유연한 스키마      | 상품 카탈로그  | MongoDB, Couchbase |
| 컬럼 패밀리 저장소 | 열(Column) 그룹 | 대용량 분산/분석    | 로그/시계열   | Cassandra, HBase   |
| 그래프 DB     | 노드, 엣지       | 복잡한 관계 탐색    | 추천/이상 탐지 | Neo4j              |

- 키-값 저장소: 특정 키로 굉장히 빨리 값을 찾는다, 특정 ID로 값을 읽을 때 (Redis)
- 문서 DB (Document DB): JSON 스타일로 데이터 저장 (MongoDB)
- 컬럼 패밀리 저장소: 대용량 분석에 많이 쓰임
- 그래프 DB: 소셜 네트워크 분석 등

NoSQL은 RDBMS를 대체한다기보다는 상호 보완적인 관계로 이해하는 게 좋다.

예를 들어 쇼핑몰의 경우,
핵심 데이터는 RDBMS에 저장하되, 특정 기능(예: 실시간 인기 검색어, 사용자 세션 관리, 상품 추천 등)은 NoSQL을 사용할 수도 있다.


> **<실무 이야기: NoSQL 도입>**
> RDB는 만능 해결사다.
> 그러므로 서비스가 작을 때는 RDB를 사용하다가
> 서비스가 커지고, 사용자가 기하급수적으로 늘면서 NoSQL이 꼭 필요해지면
> 그때 각 상황에 맞는 NoSQL을 부분적으로 도입해야 한다
> 
> 중요도로 치면
> RDB 90-95%
> NoSQL(이외 DB) 5-10%
> 
> RDB부터 제대로 알자!
> 다른 DB를 사용하는 것은 관리 비용이 늘어난다는 점에서
> 실무에서 도입할 때는 신중하게 고려해야 한다!!!!
> 최신 기술이라고 해서 이것저것 써보는 게 나쁜 건 아니지만,
> RDB 하나만 제대로 이해하기도 쉽지 않다. (수십년간 쌓여온 기술)
> 참고로, 사용자가 수백만명 이상이더라도 RDB로 대부분의 서비스는 충분하다.
> 
> 회사 업무에서 사용하는 것의 90%는 RDB
> RDB를 제대로 이해하고 잘 다뤄야 하고,
> 그 이후에 남는 에너지로 NoSQL에 대해 공부해야 한다.
> 
> RDB에 대한 깊이도 없는데 NoSQL을 쓴다?
> RDB를 깊이 있게 공부하게 되면,
> RDB로도 대부분의 문제가 해결이 가능하다는 걸 알게 된다.
> 그럼 나중에 사용자가 많아졌을 때,
> 언제 NoSQL을 써야 할지 정확한 판단이 가능해진다.
> 그렇지 않으면, 어설프게 알고 NoSQL을 도입함으로서
> 소중한 시간과 자원을 낭비할 수 있다. (관리 비용)
> 
> 즉, 어설프게 알고 도입하면 실패 가능성이 높다.
> RDB를 먼저 제대로 이해하자.
> 그러면 나머지도 더 제대로 이해할 수 있을 것이다.

결론
==다양한 DBMS가 있지만, 첫 번째 목표는 RDBMS==
==그 중에서도 MySQL을 확실하게 마스터하는 것이다.==
이것만 잘해도 대부분의 상황에 잘 대처할 수 있다!


### 10강. 관계형 데이터베이스 종류

#### 실무에서 사용되는 RDBMS 종류

실무에서 사용되는 다양한 RDB들을 알아보자!
##### Oracle (오라클 데이터베이스)
- 매우 강력, 끝도 없이 많은 기능, 안정성도 최고 수준의 상용 RDB 대표 주자.
- 주로 대기업, 금융권에서 사용
- 단점: 매우 비싼 라이선스 비용(수천만원부터 시작), 높은 전문성 요구

##### MySQL (마이에스큐엘)
- 전세계에서 가장 널리 사용되는 오픈 소스 RDB. 특히 웹 어플리케이션 분야에서 압도적인 점유율을 차지.
- 커뮤니티 에디션만으로도 충분 (상용 버전(Enterprise Edition)은 유료)
- 중소 규모 서비스, 스타트업에서 비용 효율적으로 사용 가능. 최근에는 대기업, 금융권에서도 사용하는 추세
- 단점: 복잡한 분석 쿼리, 대규모 트랜잭션 처리 성능은 상용 RDB, PostgreSQL에 비해 부족하다는 평도 있었으나 8.0 버전이 나오면서 개선 중.

##### PostgreSQL (포스트그레스큐엘, 포스트그레스)
- MySQL과 마찬가지로, 오픈 소스 RDB. 
- 기능이 많아서 Oracle에서 넘어갈 때 고려를 많이 함. 최근 떠오르는 오픈 소스 RDB.
- 기능은 MySQL보다 뛰어난 부분이 많다. (복잡한 쿼리 처리, 표준 SQL 준수, 확장 기능(플러그인이 많음) 등). 최근 인기가 급상승.
- 단점: 국내 전문가가 적다. (Oracle, MySQL에 비해 다룰 줄 아는 DBA가 적다.)

##### Microsoft SQL Server (MS SQL)
- MS에서 만든 상용 RDB. 윈도우 서버, 닷넷(.NET) 쓰면 많이 선택함
- 단점: 마이크로소프트 기술 스택 환경, 오픈 소스와 거리가 있음

##### MariaDB (마리아 DB)
- MySQL과 기능상 차이가 거의 없음. MySQL이 Oracle에 인수된 후 MySQL 창립 멤버들이 오픈 소스 정신을 이어나가겠다고 만든 RDB. 대부분 MySQL과 호환됨.

##### H2 Database (SQLite)
- 주로 임베디드(내장형) DB. 즉, 별도의 서버를 띄우는 게 아니라 앱 자체에 포함되어 실행되는 가벼운 DB. 주로 개발 단계에서의 빠른 테스트, 모바일 앱 내부 데이터 저장, 소규모 데스크탑 앱 등에 적합함. (실제 웹 서비스에는 약함)

---

#### MySQL 소개

- 스웨덴의 한 회사(MySQL AB) 개발, 썬 마이크로시스템즈를 거쳐 현재 오라클이 인수해 관리
- 여전히 오픈소스
- 처음부터 빠른 속도, 높은 안정성, 사용 편의성을 목표로 개발됐고, 웹 애플리케이션과 궁합이 좋아 인기가 많았음

#### RDBMS의 호환성, ANSI SQL 표준

- RDB마다 사용법이 달라서 하나 배워도 다른 건 새로 배워야하는 거 아니야? -> 그렇지 않다
- ANSI/ISO에서 지정한 SQL 표준이 존재
- 대부분의 RDB는 준수하려고 노력함 (물론 고유 기능이나 문법은 있지만, 기본적 문법은 비슷)
- ==결론적으로, MySQL을 통해 RDB의 핵심 개념, 표준 SQL을 제대로 배우면, 다른 종류의 데이터베이스(Oracle, PostgreSQL)를 접해도 쉽게 적응하고 사용할 수 있다.==

#### 실무 이야기 - DB 선택

현실적으로 오라클 / MySQL(MariaDB) 두가지
일반적인 웹서비스의 경우.
그래도 요즘은 PostgreSQL은 좀 늘어나고 있음

1. 국내 인력 수급 - 개발자나 DBA 구할 때.
2. 비용과 규모에 따른 선택 - 대기업/금융기관/공공기관은 오라클, 중소기업/스타트업/웹서비스의 경우 MySQL.
3. 학습과 개발 편의성 - MySQL은 쉽다
4. 최근 동향 - 비용 절감 니즈로 최근에는 대기업/금융기관/공공기관에서도 오픈소스 RDB 도입을 검토하거나, 이미 적용 중. 과거보다 오픈소스 RDB의 성능이 좋아짐(대규모 트랜잭션 처리, 안정성, 보안 기능). 예전에는 상용 RDB보다 못하다는 인식이 있었으나 최근에는 충분함.

결론
안정성은 오라클, 싸고 빠른 건 MySQL

강의 목표
실습은 MySQL, 강의 내용은 RDBMS를 아우르는 보편적 지식. (핵심 개념)

### 11강. 관계형 데이터베이스 핵심 개념

관계형 데이터베이스는 데이터를 표 형태로 관리한다.

- 테이블 - 엑셀 시트
- 행(Row), 레코드, 튜플 - 가로. 데이터 항목 하나
- 열(Column), 속성, 필드 - 세로. 어떤 종류의 데이터인지

#### 핵심 개념 1 - 기본 키 (Primary Key, PK)

◾ 기본 키란?
각 데이터를 유일하게 만들어주는 식별자
테이블에 있는 모든 행들 중에 특정 행을 유일하게 식별할 수 있는 열 또는 열들의 조합

◾ 기본 키의 규칙
1. 고유성 (Uniqueness) - 중복 불가
2. NOT NULL - 빈 값 불가

◾ 기본 키의 필요성
원하는 데이터를 ==빠르고 정확하게 특정==하기 위해서 필요함
따라서 ==모든 테이블에는 기본 키를 설정==하는 게 원칙

◾ 실무 이야기
실무에서는 id라는 열을 만들고, 1부터 시작해 1씩 자동으로 증가하는 정수.
`customer_id`, `product_id`와 같이 `테이블명_id`라고 짓는 게 일반적인 관례.

#### 핵심 개념 2 - 외래 키 (Foreign Key, FK)

◾ 외래 키란?
관계형 데이터베이스의 핵심이자 꽃, 따로 떨어진 표들을 관계로 묶는 방법
==한 테이블의 열에 다른 테이블의 PK를 가져온다 (참조)==

**고객, 주문 테이블이 있다고 하면, 이 쪼개진 표들을 어떻게 연결할까?**

◾ 표를 분리했기 때문에 기존의 문제는 해결된다 (PK)
데이터 중복 - 주문이 100번 있어도 고객 정보는 DB에 중복해서 저장되지 않는다
데이터 불일치 - 주소가 바뀌어도 고객 정보에서 한 번만 수정하면 된다

◾ 특정 주문을 한 고객이 누구인지 모른다는 새로운 문제가 생긴다 (FK)
주문 테이블에 고객 테이블의 PK를 참조하는 열을 가져온다(=주문 테이블의 FK)
부모 → 자식으로 연결, PK → FK
==자식이 부모를 참조==한다고 보면 됨

간단한 개념이지만, 관계형 DB의 강력함은 이 지점에서 나온다

추가
사실, 일반적으로 많이 사용되는 기술들은 단순해야 많이 사용한다
뛰어난 기술이라 해도, 너무 복잡하면 시장에서 사장될 가능성이 높다

RDB는 사실 이게 다다
이 간단한 아이디어에서 나머지가 파생되는 것이고, 널리 사용하는 기술이 된 것

◾ 부모와 자식의 관계
- 두 테이블이 FK를 통해 관계가 있을 때를 말한다
- 자식이 부모를 찾아간다 (FK를 통해 PK를 찾는다)

◾ 외래 키의 규칙 (==외래키 제약 조건==)
- 참조 무결성(Referential Integrity) - 참조가 문제없이 깔끔하게 잘 된다. 또는 데이터가 깔끔하게 정합성을 유지한다. ==FK의 값은 PK의 값 중 하나이거나 NULL이어야 한다. (PK에 없는 값을 지정할 수 없다.)==
- 예를 들어 존재하지 않는 고객을 참조하면, 관계가 깨졌다고 한다. DB는 이런 일을 사전에 막아, 데이터의 정합성을 보장한다! (PK에 존재하지 않는 값인 경우 오류를 발생시킨다!)

◾ 외래키를 사용하는 이유?
- 논리적으로 분리된 데이터들 사이에 관계를 맺어줌
- **작고 관리하기 쉬운 여러 개의 테이블로 전체 시스템을 구조화할 수 있다**
- 이렇게 잘 구조화하는 걸 **데이터베이스 설계**라고 한다
